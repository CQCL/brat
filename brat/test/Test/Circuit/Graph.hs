module Test.Circuit.Graph (graphTests) where

-- Module for checking that the graph generated by type checking is what we expect
import Brat.Checker
import Brat.Checker.Monad
import Brat.Error
import Brat.FC
import Brat.Graph
import Brat.Load
import Brat.Syntax.Core (Term(..))
import Brat.Naming (Name, root)
import Brat.Checker
import Brat.Checker.Helpers
import Brat.Syntax.Common
import Brat.Syntax.Simple
import Brat.Syntax.Value
import Brat.UserName
import Bwd
import Test.Circuit.Common
import Test.Checking (runEmpty)

import qualified Control.Exception as CE (assert)
import Control.Monad.Except
import Data.Bifunctor
import Data.Tuple.HT
import Test.Tasty
import Test.Tasty.HUnit
import Test.Tasty.ExpectedFailure
import qualified Data.Map as M
import Data.List (delete)

fst3 (a,_,_) = a

graphTest name file graph = testCase name (runProg name file graph)

idFile = unlines
  ["main :: { a :: Qubit -o b :: Qubit }"
  ,"main = { q => q }"
  ]

swapFile = unlines
  ["main :: { a :: Qubit, b :: Qubit -o b :: Qubit, a :: Qubit}"
  ,"main = { q0, q1 => q1, q0 }"
  ]

xFile = unlines
  ["ext \"tket.X\" X :: { xa :: Qubit -o xb :: Qubit }"
  ,""
  ,"main :: { a :: Qubit -o b :: Qubit }"
  ,"main = { q => X(q) }"
  ]

rxFile = unlines
  ["ext \"Rx\" Rx(th :: Float) -> { rxa :: Qubit -o rxb :: Qubit }"
  ,""
  ,"nums :: (x :: Int), (y :: Int), (z :: Int)"
  ,"nums = 1, 2 ,3"
  ,""
  ,"xish :: { rxa :: Qubit -o rxb :: Qubit }"
  ,"xish = Rx(30.0)"
  ,""
  ,"main :: { a :: Qubit -o b :: Qubit }"
  ,"main = { q => xish(q) }"
  ]

two = unlines
  ["ext \"add\" add(a :: Int, b :: Int) -> (c :: Int)"
  ,""
  ,"one :: (n :: Int)"
  ,"one = 1"
  ,""
  ,"two :: Int"
  ,"two = add(1, one)"
  ]

one = unlines
  ["one :: (n :: Int)"
  ,"one = 1"
  ]

addN = unlines
  ["ext \"N\" N :: (value :: Int)"
  ,"ext \"add\" add(a :: Int, b :: Int) -> (c :: Int)"
  ,""
  ,"addN(inp :: Int) -> (out :: Int)"
  ,"addN(n) = add(n, N)"
  ]

addN2 = unlines
  ["ext \"N\" N :: (value :: Int)"
  ,"ext \"add\" add :: {a :: Int, b :: Int -> c :: Int}"
  ,""
  ,"addN(inp :: Int) -> (out :: Int)"
  ,"addN(n) = add(n, N)"
  ]

addNmain = addN ++ unlines
  [""
  ,"main :: Int"
  ,"main = addN(1)"
  ]

ext =
  "ext \"add\" add(a :: Int, b :: Int) -> (c :: Int)"

comment = unlines
  ["-- This is a test"
  ,""
  ,"-- This too"
  ,""
  ]

-- This allows comparing edges as sets, ignoring ordering
equalEdges :: [Wire] -> [Wire] -> Assertion
equalEdges actual expected = do
  actual <- key_by_src actual
  expected <- key_by_src expected
  traverse (uncurry wireEq) (zip (M.elems actual) (M.elems expected))
  pure ()
 where
  wireEq :: Wire -> Wire -> Assertion
  wireEq (src, s, tgt) (src', s', tgt')
   | src == src', tgt == tgt' = signalEq s s'
   | otherwise = assertFailure "Wires have different ends"

  signalEq :: Either SValue Value -> Either SValue Value -> Assertion
  signalEq (Left s) (Left t) = assertRunsOk (stypeEq "" s t)
  signalEq (Right s) (Right t) = assertRunsOk (typeEq "" (Star []) s t)
  signalEq _ _ = assertFailure "Comparing kernel signal and classical signal"

  assertRunsOk :: Checking a -> Assertion
  assertRunsOk c = case runEmpty c of
    Left err -> assertFailure (showError err)
    Right _ -> pure ()

  dup_wires s _ _ = assertFailure $ "Multiple wires for same source: " ++ (show s)
  key_by_src :: [Wire] -> IO (M.Map OutPort Wire)
  key_by_src ws = do
    let ioVals = M.fromListWithKey dup_wires (map (\w@(src,_,_) -> (src, pure w)) ws)
    M.fromList <$> (sequence $ map (\(k,iov) -> (k,) <$> iov) $ M.assocs ioVals)

mkTensor :: Checking (Name, Name, Name, [(Src, BinderType Brat)])
mkTensor = do
  (fooNode, _, foos,  _) <- next "foo" Source (B0,B0) [] [("out1", Right TNat), ("out2", Right TFloat)]
  (barNode, _, [bar], _) <- next "bar" Source (B0,B0) [] [("out1", Right TInt)]
  (quxNode, _, [qux], _) <- next "qux" Source (B0,B0) [] [("res", Right TText)]
  let outs = tensor foos [bar, qux]
  pure (fooNode, barNode, quxNode, outs)

-- This is just because we have to pass some term into checkOutputs in case it needs to produce an error message.
-- But our case should never have to produce an error message, so assert false.
dummyTerm = CE.assert False (dummyFC $ Var (PrefixName [] ""))

graphTests = testGroup "Graph" [graphTest "id" idFile idGraph
                               ,graphTest "swap" swapFile swapGraph
                               ,graphTest "X"  xFile  xGraph
                               ,expectFail $ graphTest "Rx" rxFile rxGraph
                               ,graphTest "two" two   twoGraph
                               ,graphTest "one" one   oneGraph
                               ,graphTest "addN" addN (addNGraph "thunk")
                               ,graphTest "addN2" addN2 (addNGraph "a1")
                               ,graphTest "addNmain" addNmain addNmainGraph
                               ,graphTest "ext"  ext  extGraph
                               ,graphTest "empty" "" emptyGraph
                               ,graphTest "comment" comment emptyGraph
                               ]
