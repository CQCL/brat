module Test.Circuit.Graph (graphTests) where

-- Module for checking that the graph generated by type checking is what we expect
import Brat.Error
import Brat.Graph
import Brat.Load
import Brat.Syntax.Core (Term)
import Brat.Syntax.Common (Decl(..))
import Test.Circuit.Common

import Test.Tasty
import Test.Tasty.HUnit

type Graph = Graph' Term

assertEither :: Either Error Assertion -> Assertion
assertEither (Left err) = assertFailure (debug err)
assertEither (Right ass) = ass

graphTest :: String -> String -> Graph' Term -> TestTree
graphTest name contents gExp = testCase name $ assertEither $ do
  (cenv, venv, nouns, _, _, gAct) <- loadFile Lib name contents
  -- gAct <- typeGraph (cenv, venv) (head $ [ n | n <- nouns, fnName n == "main" ])
  pure $ gAct @?= gExp

idFile =
  "main :: { a :: Qubit -o b :: Qubit }\
  \main = { q -> q }"

xFile =
  "ext \"X\" X :: { xa :: Qubit -o xb :: Qubit }\
  \\
  \main :: { a :: Qubit -o b :: Qubit }\
  \main = { q -> X(q) }"

rxFile =
  "ext \"Rx\" Rx :: (th :: Float) -> { rxa :: Qubit -o rxb :: Qubit }\
  \\
  \nums :: (x :: Int), (y :: Int), (z :: Int)\
  \nums = 1, 2 ,3\
  \\
  \xish :: { rxa :: Qubit -o rxb :: Qubit }\
  \xish = Rx(30.0)\
  \\
  \main :: { a :: Qubit -o b :: Qubit }\
  \main = { q -> xish(q) }"

-- TODO:
two =
  "ext \"add\" add :: (a :: Int), (b :: Int) -> (c :: Int)\
  \\
  \one :: (n :: Int)\
  \one = 1\
  \\
  \two :: Int\
  \two = add(1, one)"

graphTests = testGroup "Graph" [graphTest "id" idFile idGraph
                               ,graphTest "X"  xFile  xGraph
                               ,graphTest "Rx" rxFile rxGraph
                               ,graphTest "two" two ([], [])
                               ]
