# Suggested types:
# Real, Nat, Int, Bool, (X * Y), X^n, X -> Y, [ X ], D(X), Dist (âˆ€n. D(B^n))
# K-circ, O-circ
# P-circ, M-circ

type Qubit = Nat

type Dist = List Bool
type KCirc q b = Vec Qubit q -> Vec Bool b
type OCirc q b = Circ q b
type PCirc q = Vec Qubit q -> Vec Bool q
type MCirc q b = Vec Qubit q -> Vec Bool b

type Real = Nat

#sample :: Pair N D(X) -> List X
#sample = ?sample

#promote :: List X -> D(X)
#promote = ?promote

execute :: KCirc -> Dist
execute = ?execute

# shoot : K-circ -> B^q
shoot :: KCirc -> (result :: List Bool)
shoot = ?shoot

get_shots :: (nshots :: Nat), Circ -> (shots :: List Bool)
get_shots = ?get_shots

# execute_n :: Nat -> (K-circ -> Dist)
execute_n :: (n :: Nat) -> (f :: { KCirc -> Dist })
execute_n = n -> {c -> promote (get_shots((n, c)))} # partial application would be good

# P-circ, M-circ -> K-circ
composeCirc :: (n :: Nat), PCirc n, MCirc n n -> KCirc n n
composeCirc = a, b -> a; b

# ideally we want n quantified?
# [P-circ] * [M-circ] ~~> [ P-circ * M-circ ] ~~> [K-circ]
genericComposition :: List (Pair PCirc MCirc) -> List KCirc
genericComposition = ?gc

# compilationPass :: forall X Y. (ins :: (Pair X Circ)) -> (outs :: Pair Circ Y)
# compilationPass = ?cp
# 
# synthesise :: forall (X :: *) -> Circ
# synthesise = ?syn

# compile :: Circ -> Pulses

ansatz :: (params :: List Real) -> PCirc
ansatz = ?ans

# [R * M-circ]
observable :: List (Pair Real Circ)
observable = ?obs

quant :: List (List Bool) -> Real
quant = ?q

circuits_to_run :: ?hmm
circuits_to_run = (a p) o (map snd H) 

results = map((execute, circuits_to_run))
answer = energy results

evaluate :: (obs :: Observable),
            (q :: Quantity),
            (a :: Ansatz),
            (rs :: List Real)
         -> Real
evaluate = ?eval

my_eval :: List Real -> Real
my_eval = rs -> evaluate((my_obs,my_quant,a,rs))
#my_eval = evaluate (my_obs,my_quant) a

update :: (obs :: Observable),
          (q :: Quantity),
          (a :: Ansatz),
          (rs :: List R),
          (init :: Real),
       -> (result :: List R)
update = ?update

my_obs :: Observable
my_obs = ?afe

my_quant :: Quantity
my_quant = ?qa

my_update :: [R] -> R -> [R]
my_update = rs, r -> update((my_obs, my_quant, a, rs, r))
# This (below) would be better
# my_update = update((my_obs, my_quant, a))

var_loop :: ([R]-> R) -> ([R] -> R -> [R]) -> [R] -> R -> R
var_loop = eval, update, params, prev_guess ->
   new_guess = eval params
   if (good_enough(prev_guess, new_guess)) 
      return new_guess
   else
      return var_loop eval update (update params new_guess) new_guess
      
my_loop :: (rs :: List Real) -> (prev :: Real) -> (result :: Real)
my_loop = var_loop my_eval my_update

answer :: (result :: Real)
answer = my_loop initial_params initial_guess

