type A = Nat
type B = Bool
type C = Unit

-- Like the ; operator, but produces a thunk
-- (noun) with known argument type, rather than a verb
compose :: {{ A -> B }, { B -> C } -> {A -> C}}
compose(f, g) = { x => g(f(x)) }


compose1( {A -> B}, { {A -> B} -> {A -> C}} ) -> {A -> C}
compose1(f, g) = { x => (f |> g)(x) }
-- equivalent to
compose1a :: { { A -> B }, { {A -> B} -> {A -> C} } -> {A -> C} }
compose1a(f, g) = { x => (g(f))(x) }


compose2({ A -> B }, { B -> C }) -> {A -> C}
compose2(f, g) = {f ; g}

-- use the result of a composition as LHS of a function application
compose_apply :: {{A->B}, {B->C}, A -> C}
compose_apply(f,g,x) = (f;g)(x)

-- with a checkable argument:
compose_apply_chk :: {{Int -> Nat}, {Nat -> Bool} -> Bool}
compose_apply_chk(f,g) = (f;g)(2)

-- the following are all just differently-bracketed versions of the same thing
compose3 :: { { A -> B }, { B -> C } -> {A -> C} }
compose3(f, g) = { x => (x |> f; g) }

compose3a({ A -> B }, { B -> C }) -> {A -> C}
compose3a(f, g) = { x => x |> f; g }

compose3b :: { { A -> B }, { B -> C } -> {A -> C} }
compose3b(f, g) = { x => (x |> (f; g)) }

compose3c({ A -> B }, { B -> C }) -> {A -> C}
compose3c(f, g) = { x => x |> (f; g) }
