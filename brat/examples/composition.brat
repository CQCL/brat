# Expectation:
#  - These 3 'compose' functions should be equivalent

# Reality:
#  - The first has a problem looking up functions
#  - The second confuses the parser because of the thunk
#  - The third confuses the parser by using the ; operator

type A = Nat
type B = Bool
type C = Unit

# A workaround for not having the ; operator
compose :: { A -> B }, { B -> C } -> {A -> C}
compose f, g = { x -> g(f(x)) }

compose1 :: { A -> B }, { B -> C } -> {A -> C}
compose1 f, g = { x -> (f;g)(x) }

compose2 :: { A -> B }, { B -> C } -> {A -> C}
compose2 f, g = f; g
