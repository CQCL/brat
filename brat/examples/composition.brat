-- Expectation:
--  - These 3 'compose' functions should be equivalent

-- Reality:
--  - `compose1` confuses the parser because of the thunk
--  - `compose2` confuses the parser by using the ; operator

type A = Nat
type B = Bool
type C = Unit

-- A workaround for not having the ; operator
compose :: {{ A -> B }, { B -> C } -> {A -> C}}
compose(f, g) = { x => g(f(x)) }


compose1( {A -> B}, { {A -> B} -> {A -> C}} ) -> {A -> C}
compose1(f, g) = { x => (f |> g())(x) }
-- equivalent to
compose1a :: { { A -> B }, { {A -> B} -> {A -> C} } -> {A -> C} }
compose1a(f, g) = { x => (g(f))(x) }


compose2({ A -> B }, { B -> C }) -> {A -> C}
compose2(f, g) = {f(); g()}

-- the following are all just differently-bracketed versions of the same thing
compose3 :: { { A -> B }, { B -> C } -> {A -> C} }
compose3(f, g) = { x => (x |> f(); g()) }

compose3a({ A -> B }, { B -> C }) -> {A -> C}
compose3a(f, g) = { x => x |> f(); g() }

compose3b :: { { A -> B }, { B -> C } -> {A -> C} }
compose3b(f, g) = { x => (x |> (f(); g())) }

compose3c({ A -> B }, { B -> C }) -> {A -> C}
compose3c(f, g) = { x => x |> (f(); g()) }
