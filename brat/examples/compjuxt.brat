ext "" f :: { Nat -> Int }
ext "" g :: { Int -> Nat }
ext "" idi :: { Int -> Int }
ext "" idn(Nat) -> Nat
ext "" addn(Nat, Nat) -> Nat

-- Juxtapose thunks, forcing the rows
id2 :: { Nat, Nat -> Nat, Nat }
id2 = { (f,f)(); (g,g)() }
-- Same function, but without curly braces
id2'(Nat, Nat) -> Nat, Nat
id2' = (f,f)(); (g,g)()

-- Juxtapose compositions of verbs
id2a :: { Nat, Nat -> Nat, Nat }
id2a = { (f();g()), (f();g()) }
id2a' :: { Nat, Nat -> Nat, Nat }
id2a' = (f();g()), (f();g())

-- Compose juxtapositions of verbs
id2b :: { Nat, Nat -> Nat, Nat }
id2b = { f(), f(); g(), g() }
id2b'(Nat, Nat) -> Nat, Nat
id2b' = f(), f(); g(), g()

swap :: { a :: Nat, b :: Nat -> b :: Nat, a :: Nat }
swap = { x, y => a:id2(x, y) }
swap' :: { a :: Nat, b :: Nat -> b :: Nat, a :: Nat }
swap' = x, y => a:id2(x, y)

funky_application :: { a :: Nat, b :: Nat -> Nat }
funky_application = { x, y => x, y |> addn() }
funky_application' :: { a :: Nat, b :: Nat -> Nat }
funky_application' = x, y => x, y |> addn()


int :: { -> Int }
int = { => idi(1) }
int' :: Int
int' = idi(1)

port_pull(Nat) -> n :: Nat, i :: Int
port_pull = { x => i:x, x |> f(), idn() }
port_pull' :: { Nat -> nat :: Nat, int :: Int }
port_pull' = x => int:x, x |> f(), idn()


addi(Int, Int) -> Nat
addi = { g(), g(); addn() }
addi' :: { Int, Int -> Nat }
addi' = g(), g(); addn()


f :: { Nat, Nat, Int -> Int, Nat, Int}
f = { (f,f)(), idi(); idi(), g(), idi() }
f' :: { Nat, Nat, Int -> Int, Nat, Int }
f' = (f,f)(), idi(); idi(), g(), idi()
