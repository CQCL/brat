{-# LANGUAGE
ConstraintKinds,
FlexibleContexts,
MultiParamTypeClasses
#-}

module Brat.Checker (check
                    ,run
                    ,VEnv
                    ,Checking
                    ,Connectors
                    ,Graph
                    ,Modey(..)
                    ,Node
                    ,CheckingSig(..)
                    ,checkClauses
                    ,TypedHole(..)
                    ,Wire
                    ,wire
                    ,wrapError
                    ,next, knext
                    ,localFC
                    ,emptyEnv
                    ,checkOutputs
                    ,CheckConstraints
                    ,TensorOutputs(..)
                    ) where

import Control.Monad (unless, foldM)
import Control.Monad.Freer
import Data.Functor (($>))
import Data.List (intercalate, transpose)
import Data.List.NonEmpty (NonEmpty(..), last)
import qualified Data.Map as M
import Prelude hiding (filter, last)

import Brat.Checker.Combine (combinationsWithLeftovers)
import Brat.Checker.Helpers
import Brat.Checker.Monad
import Brat.Checker.Quantity
import Brat.Checker.Types
import Brat.Error
import Brat.FC
import Brat.Graph
import Brat.Naming
import Brat.Search
import Brat.Syntax.Common
import Brat.Syntax.Core
import Brat.UserName

mergeEnvs :: [Env a] -> Checking (Env a)
mergeEnvs = foldM combineDisjointEnvs M.empty

emptyEnv :: Env a
emptyEnv = M.empty

singletonEnv :: (?my :: Modey m) => String -> (Src, ValueType m) -> Env (EnvData m)
singletonEnv x input@(_, ty) = case ?my of
  Braty -> M.singleton (plain x) [input]
  Kerny -> let q = if copyable ty then Tons else One
           in  M.singleton (plain x) (q, input)


-- Run a type-checking computation, and ensure that what comes back
-- is a classical thunk or kernel as appropriate for `mode`
onlyThunk :: (?my :: Modey m)
          => Checking (Outputs Brat Syn, Connectors Brat Syn Noun)
          -> Checking (Src, [(Port, ValueType m)], [(Port, ValueType m)])
onlyThunk comp = do
  (outs, ((), ())) <- comp
  outs1 <- case outs of
    [] -> err $ ExpectedThunk (showMode ?my) "empty row"
    x:xs -> pure (x :| xs)
  rows <- combinationsWithLeftovers outs1
  let (out, emptyUnders) = last rows
  ensureEmpty "onlyThunk unders" emptyUnders
  case (?my, out) of
    (Braty, (src, C (ss :-> ts))) -> pure (src, ss, ts)
    (Kerny, (src, K (R ss) (R ts))) -> pure (src, ss, ts)
    _ -> err $ ExpectedThunk (showMode ?my) (showRow (out :| []))

-- Allows joining the outputs of two nodes together into a `Combo` node
vtensor :: (?my :: Modey m) => [(Src, ValueType m)] -> [(Src, ValueType m)] -> Checking [(Src, ValueType m)]
vtensor ss [] = pure ss
vtensor [] ts = pure ts
vtensor ss ts = do
  let sig = mergeSigs (rowToSig ss) (rowToSig ts)
  tensorNode <- anext "tensor" (Combo Row) sig sig
  mapM (\((src,ty),dstPort) -> awire (src,ty,(tensorNode,dstPort)))
       (zip (ss ++ ts) (map fst sig))
  pure $ sigToRow tensorNode sig

class TensorOutputs d where
  tensor :: d -> d -> Checking d

instance TensorOutputs () where
  tensor () () = pure ()

instance TensorOutputs [(Src, VType)] where
 tensor = let ?my = Braty in vtensor

instance TensorOutputs [(Src, SType)] where
 tensor = let ?my = Kerny in vtensor

type CheckConstraints m =
  (Eq (ValueType m)
  ,Show (ValueType m)
  ,TensorOutputs (Outputs m Syn)
  ,TensorOutputs (Outputs m Chk)
  )

checkThunk :: WC (Term Chk Verb) -> Unders Brat Chk -> Checking (Unders Brat Chk)
checkThunk _ [] = err $ InternalError "checkThunk called with empty unders"
checkThunk tm (u:us) =
  combinationsWithLeftovers (u :| us) >>= aux
 where
  aux ((ty, lo) :| opts) = (catchErr $ tryToCheckThunk ty) >>= \case
    Right () -> pure lo -- success
    Left err -> case opts of
         -- option failed; try another, or throw last error
         -- TODO: rollback any nodes/wires generated by failure
      [] -> req (Throw err)
      (h:t) -> aux (h :| t)

  -- Type check a thunk against a single combination type, return void for success
  checkCombination :: (CheckConstraints m, ?my :: Modey m)
                => Src -> [(Port, ValueType m)] -> [(Port, ValueType m)] -> VType
                -> Checking ()
  checkCombination src ins outs fty = do
    source <- anext "src" Source [] ins
    target <- anext "tgt" Target outs []
    -- The box is always a `Brat` `Thing` (classical)
    box <- next (show src ++ "_thunk") (source :>>: target) [] [("fun", fty)]
    ((), (emptyOvers, emptyUnders)) <- check tm (sigToRow box ins, sigToRow box outs)
    ensureEmpty "checkCombination overs" emptyOvers
    ensureEmpty "checkCombination unders" emptyUnders

  -- Split on the type to determine in which mode to `checkCombination`
  tryToCheckThunk :: (Src, VType) -> Checking ()
  tryToCheckThunk (src, ty) = case ty of
    C (ss :-> ts) -> let ?my = Braty in checkCombination src ss ts ty
    K (R ss) (R ts) -> let ?my = Kerny in checkCombination src ss ts ty
    _ -> typeErr "Not a function type"

checkInputs :: (CheckConstraints m, ?my :: Modey m)
            => WC (Term Syn k)
            -> [(Src, ValueType m)]
            -> [(Tgt, ValueType m)]
            -> Checking [(Src, ValueType m)]
checkInputs _ overs [] = pure overs
checkInputs tm@(WC fc _) (o:overs) (u:unders) = localFC fc $ checkWire o u >>= \case
  Just () -> checkInputs tm overs unders
  Nothing -> err $ TypeMismatch (show tm) (showRow (u :| unders)) (showRow (o :| overs))
checkInputs tm [] unders = typeErr $ "No overs but unders: " ++ show unders ++ " for " ++ show tm

checkOutputs :: (CheckConstraints m, ?my :: Modey m)
             => WC (Term Syn k)
             -> [(Tgt, ValueType m)]
             -> [(Src, ValueType m)]
             -> Checking [(Tgt, ValueType m)]
checkOutputs _ unders [] = pure unders
checkOutputs tm@(WC fc _) (u:unders) (o:overs) = localFC fc $ checkWire o u >>= \case
  Just () -> checkOutputs tm unders overs
  Nothing -> err $ TypeMismatch (show tm) (showRow (u :| unders)) (showRow (o :| overs))
checkOutputs tm [] overs = typeErr $ "No unders but overs: " ++ show overs ++ " for " ++ show tm

checkClauses :: (?my :: Modey m, CheckConstraints m)
             => Clause Term Verb
             -> Connectors m Chk Verb
             -> Checking (Outputs m Chk
                         ,Connectors m Chk Verb)
checkClauses Undefined _ = err (InternalError "Checking undefined clause")
checkClauses (NoLhs verb) conn = check verb conn
checkClauses (Clauses cs) conn = do
  (res :| results) <- mapM (\c@(lhs, rhs) ->
    check (WC (clauseFC c) (lhs :\: rhs)) conn) cs
  unless (all (== res) results)
    (fail "Clauses had different rightovers")
  pure res
 where
  clauseFC (lhs, rhs) = FC (start $ fcOf lhs) (end $ fcOf rhs)

check :: (CheckConstraints m, TensorOutputs (Outputs m d), ?my :: Modey m)
      => WC (Term d k)
      -> Connectors m d k
      -> Checking (Outputs m d
                  ,Connectors m d k)
check (WC fc tm) conn = localFC fc (check' tm conn)

check' :: (CheckConstraints m, TensorOutputs (Outputs m d), ?my :: Modey m)
       => Term d k
       -> Connectors m d k
       -> Checking (Outputs m d
                   ,Connectors m d k) -- rightovers
check' Empty tys = pure ((), tys)
check' (s :|: t) tys = do
  -- in Checking mode, each LHS/RHS removes the wires/types it produces from the Unders remaining,
  -- including components of thunks joined together by (Combo Thunk)s in checkOutputs
  (outs, tys)  <- check s tys
  (outs', tys) <- check t tys
  -- in Synthesizing mode, instead we join together the outputs here
  -- with a (Combo Row), although the latter node may not be useful
  outs <- tensor outs outs'
  pure (outs, tys)
check' (s :-: t) (overs, unders) = do
  (overs, (rightovers, ())) <- check s (overs, ())
  (outs,  (emptyOvers, rightunders)) <- check t (overs, unders)
  ensureEmpty "composition overs" emptyOvers
  pure (outs, (rightovers, rightunders))
check' (binder :\: body) (overs, unders) = do
  (ext, overs) <- abstract overs (unWC binder)
  (outs, ((), unders)) <- localEnv ext $ check body ((), unders)
  pure (outs, (overs, unders))
check' (Pull ports t) (overs, unders) = do
  unders <- pullPorts ports unders
  check t (overs, unders)
check' (t ::: outs) (overs, ()) | Braty <- ?my = do
  (unders, dangling) <- mkIds outs
  ((), overs) <- noUnders $ check t (overs, unders)
  pure (dangling, (overs, ()))
 where
  mkIds :: [Output] -> Checking ([(Tgt, VType)] -- Hungry wires
                                ,[(Src, VType)]) -- Dangling wires
  mkIds [] = pure ([], [])
  mkIds ((port, ty):outs) = do
    node <- next "id" Id [(port, ty)] [(port, ty)]
    (hungry, dangling) <- mkIds outs
    pure (((node, port), ty):hungry, ((node, port), ty):dangling)
check' (Emb t) (overs, unders) = do
  (outs, (overs, ())) <- check t (overs, ())
  unders <- checkOutputs t unders outs
  pure ((), (overs, unders))
check' (Th t) conns = case ?my of
  Braty -> let ((), unders) = conns in ((),) . ((),) <$> checkThunk t unders
  Kerny -> typeErr "no higher order signals! (Th)"
check' (Force th) (overs, ()) = do
  (outs, ((), ())) <- let ?my = Braty in check th ((), ())
  -- pull a bunch of thunks (only!) out of here
  (_, thUnders, thOvers) <- getThunks ?my outs
  overs <- checkInputs th overs thUnders
  pure (thOvers, (overs, ()))

check' (Var x) ((), ()) = case ?my of
  Braty -> (, ((), ())) <$> vlup x
  Kerny -> req (KLup x) >>= \case
    Just output -> pure ([output], ((), ()))
    Nothing -> err $ KVarNotFound (show x)
check' (fun :$: arg) ((), ()) = do
  (src, ss, ts) <- onlyThunk $ let ?my = Braty in check fun ((), ())
  evalNode <- anext "eval" (Eval src) ss ts
  ((), ()) <- noUnders $ check arg ((), sigToRow evalNode ss)
  pure (sigToRow evalNode ts, ((), ()))
check' (Let abs x y) conn = do
  (dangling, ((), ())) <- check x ((), ())
  env <- abstractAll dangling (unWC abs)
  localEnv env $ check y conn
check' (NHole name) ((), unders) = req AskFC >>= \fc -> case ?my of
  Kerny -> do
    req $ LogHole $ NKHole name fc ((), unders)
    pure ((), ((), []))
  Braty -> do
    suggestions <- getSuggestions fc
    req $ LogHole $ NBHole name fc suggestions ((), unders)
    pure ((), ((), []))
   where
    getSuggestions :: FC -> Checking [String]
    getSuggestions fc = do
      matches <- findMatchingNouns
      let sugg = transpose [ [ tm | tm <- vsearch fc ty ]
                          | (_, ty) <- unders]
      let ms = intercalate ", " . fmap show <$> matches
      let ss = intercalate ", " . fmap show <$> sugg
      pure $ take 5 (ms ++ ss)

    findMatchingNouns :: Checking [[UserName]]
    findMatchingNouns = do
      let tys = snd <$> unders
      env <- req AskVEnv
      let matches = transpose $
            [ [ (nm, src) | (src, _) <- stuff ]
            | (nm, stuff) <- M.assocs env
            , and (zipWith (==) tys (snd <$> stuff))
            ]
      pure $ fmap fst <$> matches

check' (VHole name) (overs, unders) = do
  fc <- req AskFC
  req $ LogHole $ case ?my of
    Braty -> VBHole name fc (overs, unders)
    Kerny -> VKHole name fc (overs, unders)
  pure ((), ([], []))
check'
  (Con (PrefixName [] "cons") (WC _ (x :|: (WC _ (Con (PrefixName [] "cons") (WC _ (y :|: (WC _ (Con (PrefixName [] "nil") (WC _ Empty))))))))))
  ((), ((hungry, p), ty):unders) | (Braty, Product a b) <- (?my, ty) = do
  ctor <- anext "DPair" (Constructor DPair)  [("first", a), ("second", b)] [("value", Product a b)]
  noUnders $ check x ((), [((ctor, "first"), a)])
  noUnders $ check y ((), [((ctor, "second"), b)])
  awire ((ctor, "value"), Product a b, (hungry, p))
  pure ((), ((), unders))
check' pat@(Con (PrefixName [] con) arg) ((), (((hungry, p), ty):unders))
  | Just (_, n) <- getVec ?my ty = do
      n <- evalNat n
      case patternToData ?my con ty of
        Nothing -> error "uhh"
        Just node -> case conFields ?my node ty of
          Nothing -> err $ VecLength n (show ty) (case con of
            "nil" -> Length 0
            "cons" -> LongerThan 0) (show pat)
          Just ins -> do
            ctor <- anext "" (Constructor node) ins [("value", ty)]
            noUnders $ wrapError (consError n (show ty) pat) $ check arg ((), sigToRow ctor ins)
            awire ((ctor, "value"), ty, (hungry, p))
            pure ((), ((), unders))
  | Just node <- patternToData ?my con ty, Just cins <- conFields ?my node ty = do
      let couts = [("value", ty)]
      ctor <- anext (show con) (Constructor node) cins couts -- what comes out?
      let cunders = sigToRow ctor cins
      let covers = sigToRow ctor couts
      ((), ((), cUnders)) <- check arg ((), cunders)
      ensureEmpty "constructor unders" cUnders
      let [(value,_)] = covers
      awire (value, ty, (hungry, p))
      pure ((), ((), unders))
  | Just node <- patternToData ?my con ty, Nothing <- conFields ?my node ty
  = typeErr $ show pat ++ " not of type " ++ showRow (((hungry, p), ty):|unders)

check' t c = case (?my, t, c) of -- remaining cases need to split on ?my
  (Kerny, Simple (Bool _), ((), ((_, Bit):unders))) -> pure ((), ((), unders))
  (Braty, Simple tm, ((), ((src, p), SimpleTy ty):unders)) -> do
    simpleCheck ty tm
    this <- next (show tm) (Const tm) [] [("value", SimpleTy ty)]
    wire ((this, "value"), SimpleTy ty, (src, p))
    pure ((), ((), unders))
  _ -> error $ "check this: " ++ show t

consError :: Int -> String -> Term Chk Noun -> Error -> Error
consError i ty p e@Err{..} = case msg of
  VecLength _ _ l _ -> e { msg = VecLength i ty ((1+) <$> l) (show p) }
  _ -> e

abstractAll :: (Show (ValueType m), ?my :: Modey m)
            => [(Src, ValueType m)] -> Abstractor
            -> Checking (Env (EnvData m))
abstractAll stuff binder = do
  (env, unders) <- abstract stuff binder
  ensureEmpty "unders after abstract" unders
  pure env

abstract :: (Show (ValueType m), ?my :: Modey m)
         => [(Src, ValueType m)]
         -> Abstractor
         -> Checking (Env (EnvData m) -- Local env for checking body of lambda
                     ,[(Src, ValueType m)] -- rightovers
                     )
abstract inputs AEmpty = pure (emptyEnv, inputs)
abstract [] abs = err $ NothingToBind (show abs)
abstract (input:inputs) (Bind x) = pure (singletonEnv x input, inputs)
abstract inputs (x :||: y) = do
  (venv, inputs)  <- abstract inputs x
  (venv', inputs) <- abstract inputs y
  (,inputs) <$> mergeEnvs [venv, venv']
abstract inputs (APull ports abst) = do
  inputs <- pullPorts ports inputs
  abstract inputs abst
abstract ((src,ty):inputs) (Pat abs)
  | Just (ety, n) <- getVec ?my ty = (evalNat n) >>= \n -> (,inputs) <$> case abs of
    PNil -> if n == 0
      then pure emptyEnv
      else err $ VecPatLength (show abs) (show ty)
    PCons (x :||: xs) -> do
      -- A `cons` pattern on the LHS needs to have exactly two binders
      let tailTy = makeVec ety (Simple (Num (n - 1)))
      node <- anext "PCons (Vec)" (Selector DCons) [("head", ety), ("tail", tailTy)] []
      venv <- abstractAll [((node, "head"), ety)] x
      venv' <- wrapError (consPatErr abs (show ty)) $
                abstractAll [((node, "tail"), tailTy)] xs
      mergeEnvs [venv,venv']
    _ -> err $ NotVecPat (show abs) (show ty)
  | (Braty, List _, PNil) <- (?my, ty, abs) = pure (emptyEnv, inputs)
  | (Braty, Option _, PNone) <- (?my, ty, abs) = pure (emptyEnv, inputs)
  | Just (sel, abs, outs) <- patternToData ?my abs ty = do
      node <- anext (show sel) (Selector sel) [("value", ty)] outs
      awire (src, ty, (node, "value"))
      let sel' = sigToRow node outs
      let absAll = (,inputs) <$> abstractAll sel' abs
      case sel of
        DCons -> absAll
        DPair -> absAll
        _ -> abstract (sel' ++ inputs) abs
 where
  consPatErr :: Pattern Abstractor -> String -> Error -> Error
  consPatErr abs ty e@Err{msg=(VecPatLength _ _)}
    = e { msg = VecPatLength (prettyPat abs) ty }
  consPatErr _ _ e = e

  prettyPat :: Pattern Abstractor -> String
  prettyPat p = case patList p of
    Just xs -> show xs
    Nothing -> show p

  patList :: Pattern Abstractor -> Maybe [Abstractor]
  patList PNil = Just []
  patList (PCons (x :||: (Pat xs))) = (x:) <$> patList xs
  patList _ = Nothing

  patternToData :: Modey m -> Pattern Abstractor -> ValueType m
              -> Maybe (DataNode, Abstractor, [(Port, ValueType m)])
  patternToData m abs ty = do
    (sel, abs) <- (case abs of
      POnePlus abs -> Just (DSucc, abs)
      PTwoTimes abs -> Just (DDoub, abs)
      PCons (a :||: (Pat (PCons (b :||: Pat PNil))))
        | (Braty, Product _ _) <- (m,ty) -> Just (DPair, a :||: b)
      PCons abs -> Just (DCons, abs)
      PSome abs -> Just (DSome, abs)
      _ -> Nothing)
    (sel, abs, ) <$> conFields m sel ty

abstract ((_, ty):inputs) (Lit tm) = do
  litTy <- case (?my,ty) of
    (Kerny, Bit) -> pure $ Boolean
    (Braty, SimpleTy ty) -> pure $ ty
    _ -> typeErr $ "Can't match literal literal " ++ show tm ++ (showMode ?my)
  simpleCheck litTy tm $> (emptyEnv, inputs)
abstract ((_,ty):_) pat = err (PattErr $
    "Couldn't resolve pattern " ++ show pat ++ " with type " ++ show ty)

run :: (VEnv, [Decl], FC)
    -> Checking a
    -> Either Error (a, ([TypedHole], Graph))
run (ve, ds, fc) m = let ctx = Ctx { venv = ve
                                   , decls = ds
                                   , typeFC = fc
                                   } in
                       (\(a,b,_) -> (a,b)) <$> handler m ctx root
